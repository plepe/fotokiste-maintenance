#!/usr/bin/env node

/*
 * Parameter:
 * -nX  save message with msg_number X
 * -b   don't create a backup file
*/

const conf = require('./conf.json')
const MailParser = require('mailparser').MailParser
const fs = require('fs')
const mod_getopt = require('posix-getopt')
const async = require('async')
const DrupalREST = require('drupal-rest')
const getUserFromMail = require('./src/getUserFromMail')
global.fetch = require('node-fetch')

const drupal = new DrupalREST(conf.drupal)
drupal.login(() => {
  console.log('logged in')
  start_mail()
})

const wait = []
const node = {
  type: [{target_id: 'message'}],
  body: [{}],
  field_attachments: []
}

function receive_headers (headers) {
  node.title = [{value: headers.get('subject')}]
  node.created = [{value: new Date(headers.get('date')).toISOString().replace('.000Z', 'Z')}]

  if (headers.get('references')) {
    let references = headers.get('references')
    if (typeof references === 'string') {
      references = [references]
    }

    references.each(r => {
      const m = r.match(/^<node-([0-9]+)@stadtverkehr-austria-fotos>/)
      if (m) {
	node.replyto = [{target_id: m[1]}]
      }
    })
  }

  const from = headers.get('from')
  getUserFromMail(drupal, from.value[0], (err, result) => {
    if (err) { console.error(err) }
    if (result !== null) {
      node.uid = [{target_id: result.uid[0].value}]
    }
  })

  wait.headers = true

  // console.log(headers.get('references'))
//  if (headers.references) {
//    if (typeof headers.references === 'string') { data.replyto = headers.references } else if (headers.references.length > 0) { data.replyto = headers.references[headers.references.length - 1] }
//  }
//
//  mysql_conn.query('update message set ? where kistenname=? and msg_number=?', [data, conf.kiste, msg_number], function () {
//    wait.headers = false
//
//    receive_mail_callback()
//  })
}

function receive_mail_callback () {
  // Not done yet? Wait ...
  for (const i in wait) {
    if (wait[i] === true) {
      return
    }
  }

  const msg = new message(conf.kiste, msg_number)

  msg.on('message_loaded', function (ob) {
    ob.init(conf, function () {
      // mysql_conn.end()
    })
  })
}

function receive_attachment (attachment) {
  const callback = () => done()
  const mediaRef = {target_id: null}
  node.field_attachments.push(mediaRef)
  wait.push(callback)

  async.waterfall([
    (done) => {
      drupal.fileUpload({
	filename: attachment.filename,
	content: attachment.content,
      }, 'media/image/field_media_image',
      {},
      done)},
    (file, done) => {
      attachment.release()

      const media = {
	bundle: [{ target_id: 'image' }],
	name: [{ value: attachment.filename, }],
	field_media_image: [{ target_id: file.fid[0].value }],
      }

      drupal.mediaSave(null, media, {}, done)
    },
    (media, done) => {
      mediaRef.target_id = media.mid[0].value
      done()
      callback()
    }
  ])
  //  content_type: attachment.contentType
}

function receive_attachment_callback (att_id) {
  wait[att_id] = false

  receive_mail_callback()
}

function start_mail () {
  if (backup) { mailcopy = fs.createWriteStream('/tmp/y') }

  process.stdin.resume()
  process.stdin.on('data', function (chunk) {
    mailparser.write(chunk)

    if (backup) { mailcopy.write(chunk) }
  })
  process.stdin.on('end', function () {
    mailparser.end()
    if (backup) { mailcopy.end() }

    console.log(JSON.stringify(node, null, '  '))
    global.setTimeout(() => {
      console.log(JSON.stringify(node, null, '  '))
      drupal.nodeSave(null, node, {}, () => console.log('saved'))
    }, 5000)
  })
}

var att_id = 0
var msg_number = 0
let mailcopy
var backup = true

// Arguments handling
let parser, option
parser = new mod_getopt.BasicParser('bn:', process.argv)
opt = {}
while ((option = parser.getopt()) !== undefined) {
  opt[option.option] = true

  if (option.optarg !== undefined) { opt[option.option] = option.optarg }

  switch (option.option) {
    case 'n':
      msg_number = option.optarg
      break
    case 'b':
      backup = false
      break
  }
}

var mailparser = new MailParser({
  streamAttachments: true
})
wait.text = true
wait.headers = true
mailparser.on('data', data => {

  if (data.type === 'attachment') {
    receive_attachment(data)
  }
  else if (data.type === 'text') {
    if (data.html) {
      node.body[0].value = data.html
      node.body[0].format = 'basic_html'
    } else {
      node.body[0].value = data.text
      node.body[0].format = 'text'
    }

    console.log(data)
  }
  else {
  }
})
mailparser.on('headers', receive_headers)
mailparser.on('end', data => {
  console.log('END', data)
})

//var mysql_conn = mysql.createConnection(conf.db)
//message.set_mysql_conn(mysql_conn)
//mysql_conn.connect()

